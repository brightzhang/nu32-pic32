[Index](Index.md)

# Old stream-of-conscientiousness notes, ignore #

PIC to PIC CAN communication

CAN - Controller Area Network, an asynchronous serial communication protocol for nodes with a common connection through a physical layer. Nodes must use the same baud. Nodes receive every message.

It is up to the designer to give each node an identifier that sets the priority of the messages from that node and selects which nodes to listen to.

Mostly an automotive protocol, standardized by ISO and SAE. Also used in industrial controls and robotics.

Up to 1Mbps baud. CAN transceiver takes care of the differential signal, is required.

Nodes send out messages simultaneously - a message includes priority and data, and priority is used to override other messages. The peripheral takes care of the collisions and arbitration - gaurantees that the message will go through eventually, and will identify and turn off nodes that are malfunctioning.

As bits are transmitted, dominant (0) bits win over recessive (1) bits.

Each message starts with a 0, has 11 or 29 identifier bits, control bits, 0 to 8 bytes of data, a 15 bit CRC, an ACK, and ends with 7 1s.

The identifier bits (also called the Arbitration Field) act as a mask - all nodes transmit at the same time. Each compares its identifier bits to the others. When a nodes sends a 1 when another sends a 0, the node stops sending its messages, and waits to try again at the next message. So the most powerful identifier is all 0s, and the least is all 1s.

Each bit is broken up into segments called Time Quanta, used for when a bit is sampled.

Because there is no clock, bits are synchronized at the start of the message, and resynched at recessive to dominant edges (1 to 0). If there have been no edges in 5 bits, a bit is "stuffed" into the message, not a real bit, but just for synch. Happens automatically, removed automatically, but makes it weird to look at the data on a scope.

Errors are generated by failed CRC, missed stuffing, missed ACK, bad form, and more. Each node keeps a count of its errors. After 255 errors, it will turn itself off.

We will use the MCP2562 CAN transceiver, an 8 pin DIP that can work with 1.8-5.5V IO and 5V differential signal. Each node places a 120 ohm resistor between CANH and CANL.

The 795 has 2 CAN modules, C1RX on F0, C1TX on F1, C2RX on G0, C2TX on G1.

Each CAN has 32 message FIFOs, each FIFO can have 32 messages of 2 or 4 words. The FIFO buffers live in RAM, not dedicated memory. The CAN module has a direct connection to the System Bus to access memory without DMA or the CPU.

The CAN bus has 4 frames types: Data, Remote, Error, and Overload. Data is the most important, and can be Standard (11 identifier bits) or Extended (29 identifier bits).

The Arbitration Field is followed by the 6 bit Control Field. The first bit (IDE bit) identifies the message as a standard or extended frame. The second bit is reserved. The last 4 bits represent the data length code (DLC) which specifies the number of data bytes in the message (0-8).

The control field has 7 bits when using an extended frame.

A remote frame is sent by a node to request a message from another node.

An error frame is generated by any node that detects a bus error.

An overload frame is generated in the interframe space when a dominant bit is detected during the interframe space or a node is not ready for the next message.

The interframe space separates successive frames, allowing time to process the previous message.

When the CAN module is ON, it takes over the CAN RX and TX pins. The CAN module should be put in configuration mode before turning it off to prevent errors from being generated on the bus.

Operating modes are Configuration, normal, listen-only, listen all, loopback, disable. Use the request operation mode bits (REQOP) to change the mode, wait until the operation mode bits match (OPMOD).

In config mode the error counters are cleared. In this mode the CAN module is configured and inited. Some registeres can only be changed in config mode.

In normal mode, you can send and receive messages.

In listen-only mode, the CAN is ON but passive, will listen but not generate error frames or ACKs.

In listen all mode, messages are received with errors but not marked with the error.

In loopback mode, the CAN can be tested.

Disable mode is similar to config but the errors are not reset.

The CAN module can have 32 FIFOs, FIFO0-31, minimum of one. They are independent, can be for TX or RX only, have head and tail pointers, and independent interrupts. Each has its own registers. Each requires only the start address of the first message buffer (CiFIFOBA) in the base address register. CiFIFOUAn provides the next address to use. CiFIFOCIn provides the next buffer index that the CAN module will use.

A TX buffer requires 16 bytes. An RX buffer requires 16 bytes or 8 bytes if the time stamp is not saved (data only DONLY). FSIZE is used to set the FIFO size. For optimal use, set FIFO0, then 1, then 2, ...

Steps to configure FIFOs:
1. Allocate memory for message buffer
2. Put CAN in config mode
3. Update FIFO base address register CiFIFOBA with physical start address of buufer 0
4. Update FSZIE and TXEN
5. Place CAN in normal mode

For TX:
The FIFO user address CiFIFOUAn provides the physical address of the next message buffer where you should put your message.

Set the UINC bit (increment head/tail) after loading one message buffer to increment CiFIFOUAn, then the message is ready for TX. CiFIFOUAn rolls over to the start of the FIFO when it has reached the end of the FIFO, so you do not need to remember the FIFO location.

So to load a message for TX:
1. Read CiFIFOUAn and store a message there (4 ints)
2. Set the UNIC bit to increment the address
3. Set message send request TXREQ to TX the message
4. Repeat 2 and 3 for the number of messages and the size of the FIFO

For RX:
After getting a message, get the physical address of it from CiFIFOUAn.

Tell the module it can overwrite the address by setting UINC.

So to read a message from RX:
1. Use an interrupt or whatever to determine if there is a message to read (RXNEMPTYIF)
2. Read 4 ints from CiFIFOUAn
3. Set UNIC
4. Repeat as long as interrupt condition is not cleared

You can reset a FIFO by setting FRESET, going to config mode, or turning module off.

TX message format:
Up to 32 message buffers, 4 ints each - CMSGSID, CMSGEID, CMSDATA0, CMSDATA1. SID and EID have the identifier (standard or extended).

It is useful to have a struct to contain the bits of the 4 ints, hence the union typedef CANTxMessageBuffer.

The CAN module will select the messages to be sent by the priority we set for each message buffer using its ID. Set TXREQ to send out the buffers, and wait for it to be cleared.

Check to make sure the FIFO is not full of unsent messages using TxNFULLIF before adding more data to be sent.

So to TX messages:
1. Configure the FIFOs for TX
2. Set the priority of the individual FIFOs
3. Create a TX message
4. If TxNFULLIF is clear, skip to 7
5. Read CiFIFOUAn and store message there
6. Set UINC
7. Set TXREQ
8. Repeat 3 to 6 for the number of messages to be sent out
9. Can monitor the FIFO interrupts to check the status of whats going on

Priority levels are set by TXPR, with 4 levels - highest, high, low, lowest. If 2 FIFOs have the same priority, the larger number FIFO is used first (FIFO31 before 30 .. before 0).

A CAN message can be sent to request a transmit from another mode using the RTREN bit and the message will have no data.

Message Filtering

All nodes receive all messages, but will only pay attention to certain messages using a filtering mechanism, performed on the ID of the message. Set the filter to match the ID you want to pay attention to. There are 32 filters and 4 mask registers.

FLTEN turns on a filter. MSELn sets the mask. FSELn defines the FIFO destination buffer pointer for a message that matches. The masks can be used to ignore certain bits in the filter, so a FIFO can get several different sourced messages. Filters can be modified in config, normal and disable modes.

To configure a filter:
1. Update SID in CiRXFn
2. Clear EXID to match messages with the same SID only
3. Create a mask in CiRXMn, set MIDE to match SID only
4. Set FSELn to the filter register used to point to the FIFO, set the MSELn to use the mask if you set it up
5. Enable the filter by setting FLTEN

Message RX:
When a match is made, the module message index bits (CFIFOCI) will be updated, and the interrupt flags will be updated. The ICODE and FILHIT bits will be updated.

A structure similar to the TX receive buffer is helpful, in this case CANRxMessageBuffer.

If DONLY is set, only the data bytes are saved, the time stamp is discarded.

To read a CAN message:
1. Read CiFIFOUAn to get the physical address of the buffer
2,3. Process to 2 or 4 data bytes, depending on DONLY
4. Set the UINC after processing the data

Bit Timing
1. Calculate the bit time quantum freq, Ftq, an integer (8-25) times Fbaud
2. Set the baud prescaler, CiFG = (Fsys/(2\*Ftq))-1
3. Set the individual bit time segments, some constraints

# Introduction #

Messaging in simple once a CAN bus is set up. All PICs on the bus can hear every message, and are pre-configured to save messages with specific IDs. All you have to do is see if there is a message to read. Send is even easier - fill up a packet to send to a specific ID and it will (eventually) be sent out, depending on how many more important messages are being sent out on the bus.

## Code ##

The CAN bus is made of two PIC32s with MCP2562s. One PIC32 transmits two messages every second. One message has ID 0x100, and sends the value 0 to 99. The second message has ID 0x102, and sends two values, 50 to 149, and 100 to 199. The other PIC sets up filters for 0x100 and 0x102, and when data is received, send it to the computer over UART.

TX code:

```
// CAN transmit code
// At 1Hz, will send one value to SID 0x100 and two values to SID 0x102

#include <plib.h> // CAN structures in CAN.h, not quite the same as in the datasheet bleh
#include "NU32.h"

int main(void) {
  NU32_Startup();
  char UARTmessage[50];

  // the data to send
  char i = 0; // or BYTE, as is used in PLIB for the data

  CANTxMessageBuffer * transmitMessage; // pointer to CAN TX message buffer

  // Initialize CAN
  // TX on FIFO0, with 2 messages
  //   Msg 0 - to SID 0x100, will send one value
  //   Msg 1 - to SID 0x102, will send two values

  // space for the FIFO message buffers
  // 2 messages so 8 words (2 messages x 4 words each)
  unsigned int CANFIFO[8];
  
  C1CONbits.ON = 1; // turn on CAN1

  // place CAN in config mode
  C1CONbits.REQOP = 4;
  while (C1CONbits.OPMOD != 4) {
  } // wait for the module to enter mode

  // set the baud to 250000, Tq to 10
  C1CFGbits.SEG2PHTS = 1; // phase seg 2 freely programmable
  C1CFGbits.SEG2PH = 6; // phase seg 2 is 3 Tq
  C1CFGbits.SEG1PH = 7; // phase seg 1 is 3 Tq
  C1CFGbits.PRSEG = 3; // prop seg is 3 Tq
  C1CFGbits.SAM = 1; // sample bits 3 times
  C1CFGbits.SJW = 0; // synch jump width is 2 Tq
  C1CFGbits.BRP = 8; // BRP value for 0.25Mbps

  // init C1FIFOBA with start address of FIFO buffer
  C1FIFOBA = KVA_TO_PA(CANFIFO);

  // set FIFO0 size to 2 messages and for TX
  C1FIFOCON0bits.FSIZE = 1;
  C1FIFOCON0bits.TXEN = 1;

  // place module in normal mode
  C1CONbits.REQOP = 0;
  while (C1CONbits.OPMOD != 0) {
  } // wait for module to enter mode

  // send a message every second
  while (1) {
    WriteCoreTimer(0);

    // increment the value sent, roll over at 100
    i++;
    if (i > 100) {
      i = 0;
    }

    sprintf(UARTmessage, "Sending %d to 0x100 and %d %d to 0x102 ...\r\n",i,i+50,i+100);
    NU32_WriteUART1(UARTmessage);

    // get the address of the message buffer to write to
    // clear the memory
    // load the settings and data and set the UINC bit
    // set the TXREQ bit to send the message
    //   Msg 0
    transmitMessage = (CANTxMessageBuffer *) (PA_TO_KVA1(C1FIFOUA0));
    transmitMessage->messageWord[0] = 0;
    transmitMessage->messageWord[1] = 0;
    transmitMessage->messageWord[2] = 0;
    transmitMessage->messageWord[3] = 0;
    transmitMessage->msgSID.SID = 0x100; /* Message SID */
    transmitMessage->msgEID.IDE = 0;
    transmitMessage->msgEID.DLC = 0x8; /* Data Length is 8 bytes */
    transmitMessage->data[0] = i; // first byte
    C1FIFOCON0SET = 0x2000; //same as C1FIFOCON0bits.UINC = 1; // why doesn't this work? bc microchip sucks
    C1FIFOCON0SET = 0x8; //same as C1FIFOCON0bits.TXREQ = 1;
    
    //   Msg 1
    transmitMessage = (CANTxMessageBuffer *) (PA_TO_KVA1(C1FIFOUA0));
    transmitMessage->messageWord[0] = 0;
    transmitMessage->messageWord[1] = 0;
    transmitMessage->messageWord[2] = 0;
    transmitMessage->messageWord[3] = 0;
    transmitMessage->msgSID.SID = 0x102; /* Message SID */
    transmitMessage->msgEID.IDE = 0;
    transmitMessage->msgEID.DLC = 0x8; /* Data Length is 8 bytes */
    transmitMessage->data[0] = i+50; // first byte
    transmitMessage->data[1] = i+100; // second byte
    C1FIFOCON0SET = 0x2000; //same as C1FIFOCON0bits.UINC = 1; // why doesn't this work? bc microchip sucks
    C1FIFOCON0SET = 0x8; // same as C1FIFOCON0bits.TXREQ = 1;

    while (ReadCoreTimer() < 40000000) {
    }
  }
  return 0;
}
```

RX code:

```
// CAN receive code
// At 1Hz, will get one value on SID 0x100 and two values on SID 0x102

#include <plib.h> // CAN structures in CAN.h, not quite the same as in the datasheet bleh
#include "NU32.h"

int main(void) {
  NU32_Startup();
  char UARTmessage[50];

  CANRxMessageBuffer * rxMessage; // pointer to CAN RX message buffer

  // Initialize CAN
  // Rx on FIFO0 and FIFO1, 1 message each

  // space for FIFO message buffers, 1 message on 2 FIFOs so 8 words (2 messages x 4 words each)
  unsigned int CANFIFO[8];

  C1CONbits.ON = 1; // turn on CAN1 on F0 and F1

  // place CAN in config mode
  C1CONbits.REQOP = 4;
  while (C1CONbits.OPMOD != 4) {
  } // wait for the module to enter mode

  // set the baud to 250000, Tq to 10
  C1CFGbits.SEG2PHTS = 1; // phase seg 2 freely programmable
  C1CFGbits.SEG2PH = 6; // phase seg 2 is 3 Tq
  C1CFGbits.SEG1PH = 7; // phase seg 1 is 3 Tq
  C1CFGbits.PRSEG = 3; // prop seg is 3 Tq
  C1CFGbits.SAM = 1; // sample bits 3 times
  C1CFGbits.SJW = 0; // synch jump width is 2 Tq
  C1CFGbits.BRP = 8; // BRP value for 0.25Mbps

  // init C1FIFOBA with start address of FIFO buffer
  C1FIFOBA = KVA_TO_PA(CANFIFO);

  // set FIFO0 size to 1 message and for RX
  C1FIFOCON0bits.FSIZE = 0;
  C1FIFOCON0bits.TXEN = 0;

  // set FIFO1 size to 1 message and for RX
  C1FIFOCON1bits.FSIZE = 0;
  C1FIFOCON1bits.TXEN = 0;

  // set up the RX filters for 0x100 and 0x102
  C1FLTCON0bits.FSEL0 = 0; // Filter 0 store to FIFO0
  C1RXF0bits.SID = 0x100; // Filter 0 SID
  C1RXF0bits.EXID = 0; // Filter only SID messages, not EID
  C1RXM0bits.SID = 0x7FF; // match every bit in SID
  C1RXM0bits.MIDE = 1; // match only message types (SID, not also EID)
  C1FLTCON0bits.FLTEN0 = 1; // enable Filter 0

  C1FLTCON0bits.FSEL1 = 1; // Filter 1 store to FIFO1
  C1RXF1bits.SID = 0x102; // Filter 1 SID
  C1RXF1bits.EXID = 0; // Filter only SID messages, not EID
  C1RXM1bits.SID = 0x7FF; // match every bit in SID
  C1RXM1bits.MIDE = 1; // match only message types (SID, not also EID)
  C1FLTCON0bits.FLTEN1 = 1; // enable Filter 1

  C1FIFOINT0bits.RXNEMPTYIE = 1; // enable RX interrupt when buffer is not empty on FIFO0
  C1FIFOINT1bits.RXNEMPTYIE = 1; // enable RX interrupt when buffer is not empty on FIFO1

  // place module in normal mode
  C1CONbits.REQOP = 0;
  while (C1CONbits.OPMOD != 0) {
  } // wait for module to enter mode

  // if you got anything send it to the computer
  while (1) {
    // check if there is a message to read on FIFO0
    if (C1FIFOINT0bits.RXNEMPTYIF == 1) {
      // get the address of the buffer to read
      rxMessage = PA_TO_KVA1(C1FIFOUA0);

      // update message buffer pointer
      C1FIFOCON0SET = 0x2000; //C1FIFOCON0bits.UINC = 1; // why doesn't this work? bc microchip sucks

      // send the data in the message to the computer, not all the bytes have data tho
      sprintf(UARTmessage, "From 0x100 %d %d %d %d\r\n", rxMessage->data[0], rxMessage->data[1], rxMessage->data[2], rxMessage->data[3]);
      NU32_WriteUART1(UARTmessage);
    }

    // check if there is a message to read on FIFO1
    if (C1FIFOINT1bits.RXNEMPTYIF == 1) {
      // get the address of the buffer to read
      rxMessage = PA_TO_KVA1(C1FIFOUA1);

      // update message buffer pointer
      C1FIFOCON1SET = 0x2000; //C1FIFOCON0bits.UINC = 1; // why doesn't this work? bc microchip sucks

      // send the data in the message to the computer, not all the bytes have data tho
      sprintf(UARTmessage, "From 0x102 %d %d %d %d\r\n", rxMessage->data[0], rxMessage->data[1], rxMessage->data[2], rxMessage->data[3]);
      NU32_WriteUART1(UARTmessage);
    }
  }

  return 0;
}
```